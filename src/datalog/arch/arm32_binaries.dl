//===- arm32_binaries.dl ------------------------------------*- datalog -*-===//
//
//  Copyright (C) 2019-2022 GrammaTech, Inc.
//
//  This code is licensed under the GNU Affero General Public License
//  as published by the Free Software Foundation, either version 3 of
//  the License, or (at your option) any later version. See the
//  LICENSE.txt file in the project root for license terms or visit
//  https://www.gnu.org/licenses/agpl.txt.
//
//  This program is distributed in the hope that it will be useful,
//  but WITHOUT ANY WARRANTY; without even the implied warranty of
//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
//  GNU Affero General Public License for more details.
//
//  This project is sponsored by the Office of Naval Research, One Liberty
//  Center, 875 N. Randolph Street, Arlington, VA 22203 under contract #
//  N68335-17-C-0700.  The content of the information does not necessarily
//  reflect the position or policy of the Government and no official
//  endorsement should be inferred.
//
//===----------------------------------------------------------------------===//
/**
Define a set predicates to abstract from ARM32 specific instruction set
and characteristics
*/

#include "arm32_jump_tables.dl"
#include "arm32_symbolization.dl"
#include "arm32_ci_heuristics.dl"

// doubleword operations require an even,odd pair of registers, e.g., r2,r3
// Rt2 isn't really encoded in the instruction, it's derived from Rt, so we
// just need to ensure Rt is even.
invalid(EA,"arm: doubleword op Rt is odd"):-
    arch.memory_access(_,EA,_,_,Rt,_,_,_,Offset), // memory access for Rt
    arch.memory_access(_,EA,_,_,_,_,_,_,Offset2), // memory access for Rt2
    Offset < Offset2,
    instruction_get_operation(EA,Operation),
    OperationRoot = substr(Operation,0,4),
    (
        OperationRoot = "LDRD";
        OperationRoot = "STRD"
    ),
    (EA band 1) = 0, // ARM mode only
    (
        // If Rt is odd, the instruction is invalid.
        arch.reg_index(Rt,Index),
        (Index band 1) = 1
        ;
        // If Rt is LR, the instruction is invalid.
        Rt = "LR"
    ).

// For T32 instructions, you must not specify SP or PC for either Rt or Rt2.
// LDRD Rt, Rt2, [Rn]
// LDRD Rt, Rt2, [Rn], #offset
invalid(EA,"thumb: doubleword op registers invalid"):-
    arch.memory_access(_,EA,_,_,Rt,_,_,_,_),
    (EA band 1) = 1, // Thumb mode only
    instruction_get_operation(EA,Operation),
    substr(Operation,0,4) = "LDRD",
    (
        Rt = "SP";
        Rt = "PC"
    ).

// Applies to all of STR,LDR,STRD,LDRD
invalid(EA,"arm: pre/post-index disallows Rt[2] eq Rn"):-
    // For LDRD operations, there will be an 'arch.memory_access' for each of
    // Rt and Rt2, so this rule will check both for conflict with Rn.
    arch.memory_access(_,EA,_,_,Rt,Rn,_,_,_),
    instruction_writeback(EA),
    Rt = Rn.

// Rm must be different from Rt and Rt2 in LDRD instructions.
// LDRD{cond} Rt, Rt2, [Rn], ±Rm
// LDRD{cond} Rt, Rt2, [Rn, ±Rm]
// LDRD{cond} Rt, Rt2, [Rn, ±Rm]!
invalid(EA,"arm: doubleword rm/rt conflict"):-
    (
        arch.memory_access(_,EA,_,_,Rt,_,Rm,_,_), Rm != "NONE";
        // Post-index form: Rm is not part of the memory access, since it is
        // only incremented afterward.
        arch.memory_access(_,EA,_,_,Rt,Rn,"NONE",_,_),
        arch.reg_reg_arithmetic_operation(EA,Rn,Rn,Rm,_,0)
    ),
    (EA band 1) = 0, // ARM mode only
    instruction_get_operation(EA,Operation),
    substr(Operation,0,4) = "LDRD",
    // For LDRD operations, there will be an 'arch.memory_access' for each of
    // Rt and Rt2, so this rule will check both for conflict with Rm.
    Rt = Rm.

invalid(EA,"arm: pc is not allowed as dest"):-
    instruction_get_operation(EA,Operation),
    (
        contains("AND",Operation);
        contains("BIC",Operation);
        contains("MOVT",Operation);
        contains("MOVW",Operation)
    ),
    instruction_get_dest_op(EA,_,Op),
    op_regdirect_contains_reg(Op,PC),
    arch.pc_reg(PC).

invalid(EA,"arm: pc is not allowed as src"):-
    instruction_get_operation(EA,Operation),
    (
        // ldm pc, {...}
        contains("LDM",Operation)
        ;
        // mov sp, pc
        contains("MOV",Operation),
        instruction_get_dest_op(EA,_,DestOp),
        op_regdirect_contains_reg(DestOp,SP),
        arch.stack_pointer(SP)
    ),
    instruction_get_src_op(EA,_,Op),
    op_regdirect_contains_reg(Op,PC),
    arch.pc_reg(PC).

invalid(EA,"arm: sp is not allowed in AND"):-
    instruction_get_operation(EA,Operation),
    substr(Operation,0,3) = "AND",
    instruction_get_src_op(EA,_,Op),
    op_regdirect_contains_reg(Op,SP),
    arch.stack_pointer(SP).

invalid(EA,"arm: deprecated bx"):-
    instruction_get_operation(EA,"BX"),
    instruction_get_op(EA,1,Op),
    op_regdirect_contains_reg(Op,Reg),
    arch.stack_pointer(Reg).

invalid(EA,"arm: pc cannot be used as index register"):-
    instruction_get_op(EA,_,Op),
    op_indirect_mapped(Op,_,_,PC,_,_,_),
    arch.pc_reg(PC).

invalid(EA,"arm: invalid mul operand (pc)"):-
    instruction_get_operation(EA,Operation),
    contains("MUL",Operation),
    instruction_get_op(EA,_,Op),
    op_regdirect_contains_reg(Op,Reg),
    arch.pc_reg(Reg).

invalid(EA,"arm: deprecated bx"):-
    instruction_get_operation(EA,"BX"),
    instruction_get_op(EA,1,Op),
    op_regdirect_contains_reg(Op,Reg),
    arch.stack_pointer(Reg).

// The following instructions do not allow PC as the destination register.
invalid(EA,"arm: invalid pc"):-
    instruction_get_operation(EA,Operation),
    (
        Operation = "MLAHS";
        Operation = "MLASHS";
        Operation = "LDRSHEQ";
        Operation = "LDRSHTEQ";
        Operation = "LDRSHTLO";
        Operation = "LDRSHTVC";
        Operation = "LDRBEQ";
        Operation = "LDRSBEQ";
        Operation = "LDRHHS";
        Operation = "LDRHTHS";
        Operation = "LDRSBHS";
        Operation = "LDRSHHS";
        Operation = "LDRSBTHS";
        Operation = "LDRSHTHS";
        contains("LDRSB",Operation);
        contains("LDRBVC",Operation);
        contains("LDRBLO",Operation)
    ),
    instruction_get_dest_op(EA,_,Op),
    op_regdirect_contains_reg(Op,PC),
    arch.pc_reg(PC).

invalid(EA,"arm: invalid arithmetic instruction with suffix s"):-
    instruction_get_operation(EA,Operation),
    strlen(Operation) >= 4,
    substr(Operation,0,3) = OP,
    (
        OP = "ADD"; OP = "SUB"; OP = "RSB";
        OP = "ADC"; OP = "SBC"; OP = "RSC"
    ),
    substr(Operation,3,1) = "S",
    instruction_get_dest_op(EA,_,Op),
    op_regdirect_contains_reg(Op,PC),
    arch.pc_reg(PC).

invalid(EA, "arm: invalid stm/ldm"):-
    instruction(EA,_,_,Operation,RegListOp,RegOp,0,_,_,_),
    BaseOperation = substr(Operation,0,3),
    (
         BaseOperation = "STM";
         BaseOperation = "LDM"
    ),
    instruction_writeback(EA),
    op_regdirect_contains_reg(RegOp,Reg),
    op_regdirect_contains_reg(RegListOp,Reg),
    (
        // Reg is not the lowest-indexed register in the reglist.
        op_regdirect_contains_reg(RegListOp,Reg2),
        arch.reg_index(Reg,RegIdx),
        arch.reg_index(Reg2,Reg2Idx),
        Reg2Idx < RegIdx
        ;
        // Reg is not allowed in the reglist in 32-bit Thumb instructions
        EA band 1 = 1, Size = 4
        ;
        // Reg is not allowed in the reglist in LDM instructions (all modes)
        BaseOperation = "LDM"
    ).

/**
Assign ARM version names to their generation number

e.g., "v7E_M" -> 7
*/
.decl arm_ver_order(Name:symbol,VersionID:unsigned)

arm_ver_order("Pre_v4", 3).
arm_ver_order("v4", 4).
arm_ver_order("v4T", 4).
arm_ver_order("v5T", 5).
arm_ver_order("v5TE", 5).
arm_ver_order("v5TEJ", 5).
arm_ver_order("v6", 6).
arm_ver_order("v6KZ", 6).
arm_ver_order("v6_M", 6).
arm_ver_order("v6S_M", 6).
arm_ver_order("v7", 7).
arm_ver_order("v7E_M", 7).
arm_ver_order("v8_A", 8).
arm_ver_order("v8_R", 8).
arm_ver_order("v8_M_Base", 8).
arm_ver_order("v8_M_Main", 8).
arm_ver_order("v8_1_M_Main", 8).
arm_ver_order("v9", 9).

invalid(EA,"hlt: min v8"):-
    arch_info("Arch",Version),
    arm_ver_order(Version,VerID),
    VerID < 8,
    instruction_get_operation(EA,"HLT").

invalid(EA,"writeback to PC"):-
    instruction_writeback(EA),
    instruction_get_op(EA,_,Op),
    op_indirect(Op,_,PCIn,_,_,_,_),
    reg_map(PCIn,PC),
    arch.pc_reg(PC).

/**
Compute the value loaded from a literal pool.
  - ldr Reg, [BaseReg, Off]
  - ldrd Reg1, Reg2, [BaseReg, Off]
  - ldm BaseReg, {Reg1,...,RegN}
*/
value_reg(EA,Reg,EA,"NONE",0,Val,1):-
    litpool_ref(_,EA,RefAddr,LitPoolOffset,_,_),
    arch.load(EA,_,_,Reg,BaseReg,_,_,RegOffset),
    track_register(Reg),
    instruction_memory_access_size(EA,_,OpSize),
    Size = min(OpSize,4),
    // arch.load includes PC-relative displacement in RegOffset for
    // PC-relative loads, and litpool_ref includes it in LitPoolOffset,
    // so we must compensate for the double-count.
    (
        arch.pc_reg(BaseReg), arch.pc_relative_disp(EA,Adjustment)
        ;
        !arch.pc_reg(BaseReg), Adjustment = 0
    ),
    Addr = RefAddr + LitPoolOffset + as(RegOffset-Adjustment,unsigned),
    !relocation(Addr,_,_,_,_,_,_),
    data_word(Addr,Size,Val).

/**
Jump to the PC register: "bx pc"
*/
direct_jump(EA,Dest):-
    arch.jump(EA),
    instruction_get_operation(EA,Operation),
    arch.jump_operation_op_index(Operation,TargetOpIndex),
    instruction_get_op(EA,TargetOpIndex,TargetOp),
    op_regdirect_contains_reg(TargetOp,Reg),
    arch.pc_reg(Reg),
    arch.pc_relative_disp(EA,PCRelDisp),
    Dest0 = EA + as(PCRelDisp,address),
    Dest = Dest0 - (Dest0 band 1).

/**
adr r1, Label
add r, r1, r2, lsl #4
mov pc, r   or  bx r

In the above pattern, Label is supposed to be code rather than data
(literal pools).
Therefore, it should not be treated as `litpool_ref`, whose target is data.
This predicate is used for excluding such case from `litpool_ref`.
Also, the target should not be aligned.
*/
.decl pc_relative_for_jump_table(EA:address)

pc_relative_for_jump_table(EA_adr):-
    op_shifted(EA_add,3,4,"LSL"),
    substr(AddOperation,0,3) = "ADD",
    instruction_get_operation(EA_add,AddOperation),
    straight_line_def_used(EA_add,Reg,EA_jump,_),
    arch.jump(EA_jump),
    instruction_get_operation(EA_jump,Operation),
    !arch.load_word_operation(Operation),
    arch.jump_operation_op_index(Operation,Index),
    instruction_get_op(EA_jump,Index,DestOp),
    op_regdirect_contains_reg(DestOp,Reg),
    straight_line_def_used(EA_adr,Reg1,EA_add,_),
    arch.pc_relative_addr(EA_adr,Reg1,_).


direct_call(EA,Dest):-
    arch.call(EA,Index),
    instruction_get_op(EA,Index,Op),
    op_immediate(Op,Dest0),
    !instruction_has_relocation(EA,_),
    instruction_get_operation(EA,Operation),
    (
        contains("X",Operation),
        (
            (EA band 1) = 0, Dest = as(Dest0+1,address);
            (EA band 1) = 1, Dest = as(Dest0,address)
        )
        ;
        !contains("X",Operation),
        Dest = as(Dest0,address)
    ).

direct_call(EA,Dest):-
    arch.call(EA,_),
    instruction_immediate_offset(EA,_,_,_),
    instruction_has_relocation(EA,Rel),
    relocation(Rel,_,_,_,SymbolIndex,_,_),
    defined_symbol(Dest0,_,_,_,_,_,_,SymbolIndex,_),
    instruction_get_operation(EA,Operation),
    (
        contains("X",Operation),
        (
            (EA band 1) = 0, Dest = as(Dest0+1,address);
            (EA band 1) = 1, Dest = as(Dest0-1,address)
        )
        ;
        !contains("X",Operation),
        Dest = as(Dest0,address)
    ).

basic_target(Val+1):-
    defined_symbol(Val,_,_,_,_,_,_,_,Name),
    thumb_sym(Name).

basic_target(Val):-
    defined_symbol(Val,_,_,_,_,_,_,_,Name),
    !thumb_sym(Name),
    !data_sym(Name).

// Mapping symbols yield known blocks.
known_block(Block,"code",Size,"$a"):-
    arm_sym(Name),
    defined_symbol(Block,_,_,_,_,_,_,_,Name),
    block_candidate_boundaries(Block,"code",Start,End),
    Size = End - Start.

known_block(Block bor 1,"code",Size,"$t"):-
    thumb_sym(Name),
    defined_symbol(Block,_,_,_,_,_,_,_,Name),
    block_candidate_boundaries(Block,"code",Start,End),
    Size = End - Start.

/**
Either movw r, #N or movt r, #N
*/
.decl movw_movt(EA:address,Reg:register,Val:number,Operation:symbol)

movw_movt(EA,Reg,Val,Operation):-
    instruction(EA,_,_,Operation,ImmOp,RegOp,0,_,_,_),
    op_regdirect_contains_reg(RegOp,Reg),
    op_immediate(ImmOp,Val),
    (Operation = "MOVW"; Operation = "MOVT").

/**
E.g., EA_movw: movw reg, N
      EA_movt: movt reg, M
   => reg's Value = N | (M << 16)
*/
.decl movw_movt_pair(EA_movw:address,EA_movt:address,Value:number)

movw_movt_pair(EA_movw,EA_movt,Value):-
    instruction_get_operation(EA_movw,"MOVW"),
    // Given a movw, try to find the corresponding movt up to 3 instructions.
    (
        next(EA_movw,EA_movt)
        ;
        next(EA_movw,EA_temp),
        next(EA_temp,EA_movt),
        !movw_movt(EA_temp,Reg,_,"MOVW")
        ;
        next(EA_movw,EA_temp1),
        next(EA_temp1,EA_temp2),
        next(EA_temp2,EA_movt),
        !movw_movt(EA_temp1,Reg,_,"MOVW"),
        !movw_movt(EA_temp2,Reg,_,"MOVW")
    ),
    movw_movt(EA_movw,Reg,Low,"MOVW"),
    movw_movt(EA_movt,Reg,High,"MOVT"),
    Value = (High*2^16) bor Low.

/**
In some cases, a function has no explicit caller or does not have a
corresponding function symbol.
In order to initially recognize it as a code block in such cases,
treat "push {lr}", which is a typical instruction that starts a function,
as a basic target.
E.g., asterisk

FIXME: This is a heuristic: i.e., we can still miss blocks if the function
starts with other instructions. It is better to make the initial candidate
blocks by brute force, and refine them later with heuristics.
TODO: One option could be to re-define `after_end` for arm.
The current definition skips through nops only.
We could change its behavior for arm to skip also through locations that
have no instruction at all. This should allow it to skip through literal pools.
*/
basic_target(EA):-
    instruction_get_operation(EA,Operation),
    contains("PUSH",Operation),
    instruction_get_src_op(EA,_,RegBitFieldOp),
    op_regdirect_contains_reg(RegBitFieldOp,"LR").

/**
E.g.,
  add ip, pc, #0, #12
  add ip, ip, #16, #20
  ldr pc, [ip, #2640]
*/
plt_entry(EA,Function):-
    plt_entry_arm_candidate(EA,_,Function,_).

block_points(EA_entry,"code",Size,0,7,"arm: plt-block"):-
    unresolved_block(EA_entry,"code",Size),
    plt_entry_arm_candidate(EA_entry,_,_,_).

/**
E.g.,
  bx pc // thumb
  b.n XXX or nop // thumb
  add ip, pc, #0, #12
  add ip, ip, #16, #20
  ldr pc, [ip, #2640]
*/
block_points(EA-3,"code",Size,0,7,"arm: plt-block: bx pc"),
plt_block(EA-3,Function):-
    plt_entry_arm_candidate(EA,_,Function,_),
    instruction_get_operation(EA-3,Operation2), // thumb
    arch.jump_operation_op_index(Operation2,TargetOpIndex),
    instruction_get_op(EA-3,TargetOpIndex,TargetOp),
    op_regdirect_contains_reg(TargetOp,PC),
    arch.pc_reg(PC),
    block_candidate_boundaries(EA-3,"code",Start,End),
    Size = End - Start.

/**
EA_entry: The address of the PLT entry
EA_jump:  The address of the last jump instruction in the PLT entry
Function: The external function that the PLT entry forwards
EA_reloc: The destination address of the PLT entry
*/
.decl plt_entry_arm_candidate(EA_entry:address, EA_jump:address, Function:symbol, EA_reloc:address)

/**
E.g.,
  add ip, pc, #0, #12
  add ip, ip, #16, #20   or   add ip, ip, #N
  ldr pc, [ip, #2640]
*/
plt_entry_arm_candidate(EA,EA_jump,Function,as(Dest,address)):-
    plt_section(SecName),
    loaded_section(Beg,End,SecName),
    EA >= Beg,
    EA < End,

    arch.pc_reg(PC),

    // add ip, pc, #0, #12
    arch.reg_arithmetic_operation(EA,Reg,PC,1,N1),
    next(EA, NextEA),

    // add ip, ip, #16, #20
    // or
    // add ip, ip, #XXXX
    arch.reg_arithmetic_operation(NextEA,Reg,Reg,1,N2),
    next(NextEA, EA_jump),

    // ldr pc, [ip, #N]
    instruction_get_operation(EA_jump,Operation),
    arch.load_operation(Operation),
    instruction_get_src_op(EA_jump,_,OffsetOp),
    op_indirect_mapped(OffsetOp,"NONE",Reg,"NONE",_,Offset,_),
    instruction_get_dest_op(EA_jump,_,RegOp),
    op_regdirect_contains_reg(RegOp,PC),

    Dest = as(EA,number) + N1 + N2 + Offset + 8,
    relocation(as(Dest,address),_,Function,_,_,_,_).

/**
E.g.,
  movw ip, #N1
  movt ip, #N2
  add ip, pc
  ldr.w pc, [ip, #Offset]
*/
plt_entry_arm_candidate(EA,EA_jump,Function,as(Dest,address)):-
    plt_section(SecName),
    loaded_section(Beg,End,SecName),
    EA >= Beg,
    EA < End,

    arch.pc_reg(PC),

    movw_movt_pair(EA,EA_movt,Value),

    // add ip, pc
    next(EA_movt, EA_add),
    arch.reg_reg_arithmetic_operation(EA_add,Reg,PC,Reg,1,0),

    // ldr.w pc, [ip, #Offset]
    next(EA_add, EA_jump),
    instruction_get_operation(EA_jump,Operation),
    arch.load_operation(Operation),
    instruction_get_src_op(EA_jump,_,OffsetOp),
    op_indirect_mapped(OffsetOp,"NONE",Reg,"NONE",_,Offset,_),
    instruction_get_dest_op(EA_jump,_,RegOp),
    op_regdirect_contains_reg(RegOp,PC),

    // What about Offset? It seems irrelevant.
    Offset = Offset,
    Dest = as(EA_add,number) - 1 + Value,
    relocation(as(Dest,address),_,Function,_,_,_,_).

// TODO: are there more relocation types that we can use as known blocks?
known_block(Block,"code",Size,"arm: THM_CALL relocation"):-
    binary_type("REL"),
    code_in_block_candidate_refined(EA,Block),
    arch.call(EA,_),
    AlignedEA = EA - (EA band 1),
    relocation(AlignedEA,"THM_CALL",_,_,_,_,_),
    block_candidate_boundaries(Block,"code",Start,End),
    Size = End - Start.

block_points(Block,"code",Size,0,1,"arm: plt call"):-
    plt_entry_arm_candidate(BlockDest,_,_,_),
    direct_call(EA,BlockDest),
    code_in_block_candidate_refined(EA,Block),
    unresolved_block(Block,"code",Size).

/**
Prefer blocks that have a well-defined boundary with a prior literal pool.
*/
block_points(Block,"code",Size,0,1,"arm: better fit after literal pool"):-
    unresolved_block(Block,"code",Size),
    block_candidate_boundaries(Block,"code",Beg,_),
    (
        !block_candidate_boundaries(_,"code",_,Beg)
        ;
        block_candidate_boundaries(BlockPred,"code",_,Beg),
        (Block band 1) != (BlockPred band 1)
    ),
    litpool_boundaries(_,Beg).

/**
Similarly to the above rule, if the enclosed Thumb instruction does not have
any predecessor and the outer instruction has one, give penalty to the dangling
Thumb block.
*/
negative_block_points(Block,"code",Size,0,-1,"arm: dangling thumb instruction"):-
    unresolved_block(Block,"code",Size),
    (Block band 1) = 1, // Thumb mode only
    arch.dangling_thumb_instr(Block).

/**
It was observed that a valid ARM mode block often overlaps with a bad, small
Thumb block consisting of ADDS/SUBS/ASRS and B instrutions.
*/
negative_block_points(Block,"code",Size,0,-1,"arm: possibly invalid thumb block"):-
    unresolved_block(Block,"code",Size),
    (Block band 1) = 1, // Thumb mode only
    instruction(Block,2,_,Operation,_,_,_,_,_,_),
    (Operation = "ADDS"; Operation = "SUBS"; Operation = "ASRS"),
    next(Block,EANext),
    instruction(EANext,_,_,"B",_,_,_,_,_,_),
    align_addr(BlockAligned,Block),
    code_in_block_candidate_refined(BlockAligned,_).

/**
Instruction at address `EA` accesses a literal pool located at `LitPoolAddr`

EA:     EA of the instruction containing the literal-pool label.
        Note that for ADR/LDR case, EA is the address of ADR.
        For other cases, EA is the address of the load instruction.
EA_ldr: EA of the load instruction that actually accesses the literal pool
        EA = EA_ldr for non-ADR/LDR case
RefAddr: The address of referenced label
Offset: This is for handling the ADR/LDR case:
          adr BaseReg, Label
          ldr Reg, [BaseReg, Offset]
        For other cases, Offset is 0.
        The actual literal pool address would be `RefAddr + Offset`.
Size:   The whole size of the literal pool entry accessed by the instruction
        at EA_ldr:
        E.g., 1 for LDRB
              2 for LDRH
              4 for LDR
              8 for LDRD
              8 for VLDR
              N*4 for LDM R, {R1,...,RN}
OpIndex: The index of operand for literal-pool label.
        E.g., 1 for LDR, 2 for LDRD, 1 for ADR
*/
.decl litpool_ref(EA:address, EA_ldr:address, RefAddr:address, Offset:unsigned, Size:unsigned, OpIndex:operand_index)

/**
(A) LDR or LDRD
ldr Reg, [pc, off]   or   ldrd Reg1, Reg2, [pc, off]
*/
litpool_ref(EA,EA,RefAddr,0,Size,OpIndex):-
    !invalid(EA,_),
    arch.pc_reg(PC),
    arch.load(EA,_,_,Reg,PC,"NONE",_,Offset),
    !arch.memory_access("LOAD",EA,_,_,_,_,_,_,Offset-4),
    instruction_memory_access_size(EA,OpIndex,Size),
    arch.pc_relative_disp(EA,Disp),
    align_addr(EA_aligned,EA),
    RefAddr = EA_aligned + as(Disp+Offset,address),
    !arch.pc_reg(Reg).

/**
(B) ADR/LDR or ADR/LDRD
adr BaseReg, Label    or   add/sub BaseReg, pc, off
ldr Reg1, [BaseReg, Offset]  or ldrd Reg1, Reg2, [BaseReg, Offset]
*/
litpool_ref(EA,EA_ldr,RefAddr,as(Offset,unsigned),Size,OpIndex):-
    !invalid(EA,_),
    !invalid(EA_ldr,_),
    arch.pc_relative_addr(EA,BaseReg,RefAddr),
    instruction_immediate_offset(EA,OpIndex,_,_),
    straight_line_def_used(EA,BaseReg,EA_ldr,_),
    arch.load(EA_ldr,_,_,Reg1,BaseReg,"NONE",_,Offset),
    Offset >= 0,
    !arch.memory_access("LOAD",EA_ldr,_,_,_,_,_,_,Offset-4),
    instruction_memory_access_size(EA_ldr,_,Size),
    !arch.pc_reg(Reg1),
    !arch.pc_reg(BaseReg).

/**
(C) ADR/LDM
adr r1, Label    or   add/sub r1, pc, offset
ldm r1, {r2, r3}
*/
litpool_ref(EA,EA_ldm,RefAddr,0,Size,OpIndex):-
    !invalid(EA,_),
    !invalid(EA_ldm,_),
    arch.pc_relative_addr(EA,Reg,RefAddr),
    straight_line_def_used(EA,Reg,EA_ldm,_),
    instruction_get_operation(EA_ldm,Operation),
    contains("LDM",Operation),
    arch.memory_access(_,EA_ldm,_,_,_,Reg,_,_,_),
    instruction_get_dest_op(EA_ldm,_,RegBitFieldOp),
    op_register_bitfield(RegBitFieldOp,MaxIndex,_),
    !op_register_bitfield(RegBitFieldOp,MaxIndex+1,_),
    RegCnt = MaxIndex + 1,
    arch.pointer_size(Pt_size),
    Size = RegCnt * Pt_size,
    instruction_immediate_offset(EA,OpIndex,_,_).

/**
(D) ADR/VLDn
adr r1, Label    or   add/sub r1, pc, offset
vldn.type {dn,...}, r1
*/
litpool_ref(EA,EA_vld,RefAddr,0,AccessSize,OpIndex):-
    !invalid(EA,_),
    !invalid(EA_vld,_),
    arch.memory_access_aggregated("LOAD",EA_vld,Reg,_,_,_,AccessSize),
    instruction_get_operation(EA_vld,Operation),
    match("VLD[1-4].*",Operation),
    straight_line_def_used(EA,Reg,EA_vld,_),
    arch.pc_relative_addr(EA,Reg,RefAddr),
    instruction_immediate_offset(EA,OpIndex,_,_).

/*
Collect all literal pool addresses computed from `litpool_ref`s.
*/
.decl litpool_boundaries(BegAddr:address,EndAddr:address)

litpool_boundaries(LitPoolAddr,LitPoolAddr+Size):-
    litpool_ref(_,_,RefAddr,Offset,Size,_),
    LitPoolAddr = RefAddr+Offset.

/**
Create data block candidate for each valid literal pool.
*/
data_block_candidate(LitPoolAddr,Size):-
    litpool_ref(EA,_,RefAddr,LitPoolOffset,Size,_),
    LitPoolAddr = RefAddr + LitPoolOffset,
    code_in_block_candidate_refined(EA,_).

// VLDR: label must be aligned on a word boundary within -/+1KB of the
// current instruction.
alignment(LitPoolAddr,4):-
    litpool_ref(_,EA_ldr,LitPoolAddr,0,_,_),
    instruction_get_operation(EA_ldr,"VLDR"),
    instruction_get_dest_op(EA_ldr,_,DestReg),
    op_regdirect_contains_reg(DestReg,Reg),
    // Only align the first literal pool for consecutive pools.
    // If Dest reg is S, one word; two words otherwise.
    arch.float_reg(Reg,Disp),
    (
        !litpool_ref(_,_,LitPoolAddr-Disp,0,_,_)
        ;
        litpool_ref(_,EA0,LitPoolAddr-Disp,0,_,_),
        !instruction_get_operation(EA0,"VLDR")
    ).

/**
Check if the given block overlaps with a possible literal pool.
*/
.decl overlap_with_litpool(Block:address)

overlap_with_litpool(Block):-
    block_overlap(Block,"code",_,Block2,"data",LitPoolSize),
    litpool_ref(EA,_,Block2,_,LitPoolSize,_),
    code_in_block_candidate_refined(EA,Block3),
    !block_overlap(Block3,"code",_,_,"data",_).

/**
Confidence level for each literal pool
*/
.decl litpool_confidence(EARef:address, LitPoolAddr:address, Confidence:number, Reason:symbol)

.decl litpool_total_confidence(LitPoolAddr:address, Confidence:number)

litpool_total_confidence(LitPoolAddr,Total):-
    litpool_boundaries(LitPoolAddr,_),
    Total = sum X:{litpool_confidence(_,LitPoolAddr,X,_)}.

/**
There can be false positives of literal pools.
Give more points to the literal pool (data) and the ref block (code)
when it is more likely to be an actual literal pool.
*/
block_points(Block,"code",Size,0,Confidence-2,cat("litpool ref block: ",Reason)):-
    litpool_ref(EA,_,RefAddr,LitPoolOffset,_,_),
    LitPoolAddr = RefAddr + LitPoolOffset,
    code_in_block_candidate_refined(EA,Block),
    block_candidate_boundaries(Block,"code",Start,End),
    Size = End - Start,
    litpool_confidence(EA,LitPoolAddr,Confidence,Reason),
    Confidence > 2.

/**
This rule is used for transmitting the points given to a literal pool data
block to the corresponding literal-pool reference code block.
*/
.decl code_to_litpool_ref_point_transfer(Reason:symbol,Adjust:number)

code_to_litpool_ref_point_transfer("litpool ref block: adr/ldm",1).
code_to_litpool_ref_point_transfer("litpool ref block: ldr/ldrd",2).
code_to_litpool_ref_point_transfer("litpool ref block: adr/ldrd",2).
code_to_litpool_ref_point_transfer("litpool ref block: ref by non-overlapping block",2).
code_to_litpool_ref_point_transfer("litpool ref block: loaded register used somewhere",3).
code_to_litpool_ref_point_transfer("litpool ref block: possibly register param",2).
code_to_litpool_ref_point_transfer("litpool ref block: multiple litpool refs in a block",0).
code_to_litpool_ref_point_transfer("litpool ref block: valid VLDR", 2).
code_to_litpool_ref_point_transfer("litpool ref block: ldr_add_pc", 2).
code_to_litpool_ref_point_transfer("start point",0).
code_to_litpool_ref_point_transfer("function symbol",0).
code_to_litpool_ref_point_transfer("direct jump",0).
code_to_litpool_ref_point_transfer("direct call",0).
code_to_litpool_ref_point_transfer("may-fallthrough",0).
code_to_litpool_ref_point_transfer("must-fallthrough",0).

block_points(LitPoolAddr,"data",Size,0,Points,cat("litpool: ",Reason)):-
    litpool_ref(EA,_,RefAddr,LitPoolOffset,Size,_),
    code_in_block_candidate_refined(EA,Block),
    block_points(Block,"code",_,0,Points0,Reason),
    LitPoolAddr = RefAddr + LitPoolOffset,
    code_to_litpool_ref_point_transfer(Reason,Adjust),
    Points = Points0 + Adjust,
    Points > 0.

/**
ADR/LDM pair loads multiple data from literal pool.
Create `data_block_candidate` accordingly.
E.g.,
adr r2, .L_xxx
ldm r2, { r2, r3 }
.L_xxx: 8 byte data
*/
litpool_confidence(EA,LitPoolAddr,Confidence,"adr/ldm"):-
    arch.pc_relative_addr(EA,Reg,LitPoolAddr),
    straight_line_def_used(EA,Reg,EA_ldm,_),
    instruction_get_operation(EA_ldm,Operation),
    contains("LDM",Operation),
    code_in_block_candidate_refined(EA,Block),
    (
        unresolved_block(Block,"code",_),
        Confidence = 3
        ;
        !unresolved_block(Block,"code",_),
        !impossible_block(Block,"code",_,_),
        Confidence = 5
    ).

/**
Give more points in case of ldr/ldrd or adr/ldrd, which is likely a valid
instruction sequence.
*/
litpool_confidence(EA,LitPoolAddr,Confidence,"ldr/ldrd"):-
    litpool_ref(EA,EA_ldr,RefAddr,LitPoolOffset,_,_),
    LitPoolAddr = RefAddr + LitPoolOffset,
    straight_line_def_used(EA_ldr,_,EA_ldrd,_),
    instruction_get_operation(EA_ldrd,Operation),
    contains("LDRD",Operation),
    !arch.dangling_thumb_instr(EA),
    code_in_block_candidate_refined(EA,Block),
    (
        unresolved_block(Block,"code",_),
        Confidence = 3
        ;
        !unresolved_block(Block,"code",_),
        !impossible_block(Block,"code",_,_),
        Confidence = 5
    ).

data_block_candidate(LitPoolAddr,Pt_size*2):-
    arch.pc_relative_addr(EA,Reg,LitPoolAddr),
    straight_line_def_used(EA,Reg,EA_ldrd,_),
    instruction_get_operation(EA_ldrd,Operation),
    contains("LDRD",Operation),
    !arch.dangling_thumb_instr(EA),
    arch.pointer_size(Pt_size).

/**
If the ref block is not overlapping, it is likely a true literal pool.
*/
litpool_confidence(EA,LitPoolAddr,Confidence,"ref by non-overlapping block"):-
    litpool_ref(EA,_,RefAddr,LitPoolOffset,_,_),
    LitPoolAddr = RefAddr + LitPoolOffset,
    code_in_block_candidate_refined(EA,Block),
    !unresolved_block(Block,"code",_),
    !impossible_block(Block,"code",_,_),
    Confidence = 12.

/**
Even if the ref block is overlapping, if the literal pool block is not
overlapping, give 1 point.
*/
litpool_confidence(EA,LitPoolAddr,Confidence,"not overlapping"),
block_points(Block,"code",Size,0,Confidence,"litpool ref block: not overlapping"):-
    litpool_ref(EA,_,RefAddr,LitPoolOffset,LitPoolSize,_),
    LitPoolAddr = RefAddr + LitPoolOffset,
    code_in_block_candidate_refined(EA,Block),
    unresolved_block(Block,"code",Size),
    !overlap_with_litpool(Block),
    !code_in_block_candidate_refined(LitPoolAddr+(EA band 1),_),
    !unresolved_block(LitPoolAddr,"data",LitPoolSize),
    !impossible_block(LitPoolAddr,"data",LitPoolSize,_),
    Confidence = 1.

/**
Even if the ref block is overlapping, if the loaded register is used somewhere,
it is likely a literal pool.
NOTE: We can't use `def_used` here.
*/
litpool_confidence(EA,LitPoolAddr,Confidence,"loaded register used somewhere"):-
    litpool_ref(EA,EA_ldr,RefAddr,LitPoolOffset,_,_),
    LitPoolAddr = RefAddr + LitPoolOffset,
    code_in_block_candidate_refined(EA,Block),
    unresolved_block(Block,"code",_),
    !overlap_with_litpool(Block),
    arch.load(EA_ldr,_,_,Reg,_,_,_,_),
    straight_line_def_used(EA_ldr,Reg,_,_),
    Confidence = 3.

/**
Even if the ref block is overlapping and there is no known use of the loaded
register, if there's a call near in the same block, it is likely a literal
pool.
Note that the use of r may not be explicit when r is only used as an argument
of a function call.
*/
litpool_confidence(EA,LitPoolAddr,Confidence,"possibly register param"):-
    litpool_ref(EA,EA_ldr,RefAddr,LitPoolOffset,_,_),
    LitPoolAddr = RefAddr + LitPoolOffset,
    code_in_block_candidate_refined(EA,Block),
    unresolved_block(Block,"code",_),
    !overlap_with_litpool(Block),
    !straight_line_def_used(EA,_,_,_),
    code_in_block_candidate_refined(CallEA,Block),
    arch.call(CallEA,_),
    arch.load(EA_ldr,_,_,Reg,_,_,_,_),
    arch.integer_reg_param(Reg,_),
    CallEA <= EA + 12,
    Confidence = 3.

/**
If there are multiple litpool references in a block, it is likely a real code.
*/
litpool_confidence(EA,LitPoolAddr,1,"multiple litpool refs in a block"),
block_points(Block,"code",Size,0,1,"multiple litpool refs in a block"):-
    litpool_ref(EA,_,RefAddr,LitPoolOffset,_,_),
    LitPoolAddr = RefAddr + LitPoolOffset,
    code_in_block_candidate_refined(EA,Block),
    unresolved_block(Block,"code",Size),
    Count = count :{
        code_in_block_candidate_refined(EA2,Block),
        litpool_ref(_,EA2,_,_,_,_),
        instruction_get_dest_op(EA2,_,RegOp),
        op_regdirect_contains_reg(RegOp,Reg),
        straight_line_def_used(EA2,Reg,_,_)},
    Count > 3.

/**
Currently, floating-point registers are currently not tracked in
`straight_line_def_used`.
Even if the ref block is overlapping and there is no known use of the loaded
register, if the instruction appears to be a valid VLDR, it is likely a
literal.
*/
litpool_confidence(EA,LitPoolAddr,Confidence,"valid VLDR"):-
    litpool_ref(EA,EA_ldr,RefAddr,LitPoolOffset,Size,_),
    LitPoolAddr = RefAddr + LitPoolOffset,
    code_in_block_candidate_refined(EA,Block),
    unresolved_block(Block,"code",_),
    !straight_line_def_used(EA_ldr,_,_,_),
    instruction_get_operation(EA_ldr,"VLDR"),
    instruction_get_dest_op(EA_ldr,_,DestRegOp),
    op_regdirect_contains_reg(DestRegOp,Reg),
    arch.float_reg(Reg,Size),
    Confidence = 4.

litpool_confidence(EA,LitPoolAddr,9,"ldr_add_pc"):-
    init_ldr_add_pc(EA,_,_,LitPoolAddr,_,_).

/**
Even if the ref block is overlapping, if it contains a plausible instruction
sequence, it is likely a true literal pool.
*/
block_points(LitPoolAddr,"data",Size,0,Confidence,"arm: litpool: ref by block containing plausible instr seq"):-
    litpool_ref(EA,_,RefAddr,LitPoolOffset,Size,_),
    LitPoolAddr = RefAddr + LitPoolOffset,
    code_in_block_candidate_refined(EA,Block),
    unresolved_block(Block,"code",_),
    !overlap_with_litpool(Block),
    Confidence = sum X:{plausible_block(Block,X,_,_)},
    Confidence > 0.

/**
Literal pools are often placed together.
Check if there's another literal pool before or after this one.
*/
block_points(Block,"code",CodeSize,0,Points,"arm: litpool ref block: consecutive literal pools"),
block_points(LitPoolAddr,"data",Size,0,Points,"arm: litpool: consecutive literal pools"):-
    litpool_ref(EA,_,RefAddr,LitPoolOffset,Size,_),
    LitPoolAddr = RefAddr + LitPoolOffset,
    code_in_block_candidate_refined(EA,Block),
    unresolved_block(Block,"code",CodeSize),
    !overlap_with_litpool(Block),
    (Size2 = 4; Size2 = 8),
    (
        // There is a literal pool before this one.
        litpool_boundaries(LitPoolAddr-Size2,LitPoolAddr),
        litpool_total_confidence(LitPoolAddr-Size2,Confidence),
        Confidence > 1,
        (
            // There is no literal pool after this one.
            !litpool_boundaries(LitPoolAddr+Size,_),
            Points = 1
            ;
            // There is a literal pool after this one.
            litpool_boundaries(LitPoolAddr+Size,_),
            litpool_total_confidence(LitPoolAddr+Size,Confidence2),
            Confidence2 > 2,
            Points = 3
        )
        ;
        // There is no literal pool before this one, but, there is one after.
        !litpool_boundaries(LitPoolAddr-Size2,_),
        litpool_boundaries(LitPoolAddr+Size,_),
        litpool_total_confidence(LitPoolAddr+Size,Confidence1),
        Confidence1 > 1,
        Points = 1
    ).

block_points(Block,"data",Size,0,10,"arm: $d symbol"):-
    defined_symbol(Block,0,_,_,_,_,_,_,"$d"),
    data_block_candidate(Block,Size).

impossible_block(Block,"code",End-Start,"Overlaps $d symbol"):-
    defined_symbol(EA,0,_,_,_,_,_,_,"$d"),
    block_candidate_boundaries(Block,"code",Start,End),
    Start <= EA,
    EA < End.

/**
If litpool overlaps with a function symbol or $t or $a, give penalty.
*/
negative_block_points(LitPoolAddr,"data",Size,0,-20,"arm: litpool: overlapped with code symbol"):-
    litpool_boundaries(LitPoolAddr,End),
    Size = End-LitPoolAddr,
    symbol(LitPoolAddr,_,_,_,_,_,_,_,Name),
    (thumb_sym(Name); arm_sym(Name)).

block_points(Block,"data",Size,0,8,"possible string: symbol"),
data_block_candidate(Block,Size):-
    !arm_jump_table_candidate(_,_,Block,_,_,_,_,_,_),
    ascii_string(Block,End),
    Size = End-Block,
    symbol(Block,_,Type,_,_,_,_,_,Name),
    Type != "FUNC",
    !thumb_sym(Name),
    !arm_sym(Name).

block_points(Block,"data",Size,0,-5,"possible string: symbol is target"):-
    block_points(Block,"data",Size,0,8,"possible string: symbol"),
    data_block_candidate(Block,Size),
    direct_jump(_,Target), Target >= Block, Target < Block+Size.

/**
Strings are often placed together.
Check if there's another string before or after this one.
*/
block_points(Block,"data",Size,0,5,"possible string: string pred exists"),
data_block_candidate(Block,Size):-
    !arm_jump_table_candidate(_,_,Block,_,_,_,_,_,_),
    ascii_string(Block,End),
    Size = End-Block,
    aligned_address_in_data(_,Block),
    ascii_string(_,End2),
    // There could be 0~3 zeros between strings.
    (
        End2 = Block
        ;
        data_byte(End2,0),
        End2 = Block - 1
        ;
        data_byte(End2,0), data_byte(End2+1,0),
        End2 = Block - 2
        ;
        data_byte(End2,0), data_byte(End2+1,0), data_byte(End2+2,0),
        End2 = Block - 3
    ).

block_points(Block,"data",Size,0,5,"possible string: string succ exists"),
data_block_candidate(Block,Size):-
    !arm_jump_table_candidate(_,_,Block,_,_,_,_,_,_),
    ascii_string(Block,End),
    Size = End-Block,
    aligned_address_in_data(_,Block),
    ascii_string(Block2,_),
    // There could be 0~3 zeros between strings.
    (
        End = Block2
        ;
        data_byte(End,0),
        End  = Block2 - 1
        ;
        data_byte(End,0), data_byte(End+1,0),
        End  = Block2 - 2
        ;
        data_byte(End,0), data_byte(End+1,0), data_byte(End+2,0),
        End  = Block2 - 3
    ).

/**
EA:     ldr r0, LitPoolAddr
...
CallEA: bl strcmp
...
LitPoolAddr: Block
...
Block: .string "..."
*/
block_points(Block,"data",Size,0,4,"possible string: string param for string library"),
data_block_candidate(Block,Size):-
    litpool_ref(EA,EA_ldr,RefAddr,LitPoolOffset,_,_),
    LitPoolAddr = RefAddr + LitPoolOffset,
    address_in_data(LitPoolAddr,Block),
    ascii_string(Block,End),
    Size = End-Block,
    !arm_jump_table_candidate(_,_,Block,_,_,_,_,_,_),
    arch.load(EA_ldr,_,_,Reg,_,_,_,_),
    code_in_block_candidate(EA,Block2),
    code_in_block_candidate(CallEA,Block2),
    direct_call(CallEA,TargetEA),
    (
        symbol(TargetEA,_,_,_,_,_,_,_,Func)
        ;
        plt_entry(TargetEA,Func)
    ),
    arch.library_string_arg(Func,Reg).

/**
E.g.,
  0:   strb r3, [r0, #53]
  4:   ldrb r3, [r5, #1]
The strb instruction is 4 bytes, and the higher 2 bytes happens
to be subs instruction, so the blocks are overlapping.
The block with strb at 0 is real and the must-through predecessor
of the block at 4.
Whereas, the subs block do not have any successor.
To give more confidence to the real block with strb,
give points 2 to the enclosing block when the enclosing block has
a must-fallthrough even if the block is overlapping.
*/
negative_block_points(InnerBlock,"code",Size,0,-3,"arm: bogus sub-instruction"):-
    unresolved_block(InnerBlock,"code",Size),
    code_in_block_candidate_refined(EnclosingEA,_),
    must_fallthrough(_,EnclosingEA),
    EnclosingEA = InnerBlock-2,
    instruction(InnerBlock,2,_,_,_,_,_,_,_,_),
    instruction(EnclosingEA,4,_,_,_,_,_,_,_,_),
    !must_fallthrough(_,InnerBlock).

/**
A return block followed by a function symbol is likely real code.
*/
block_points(Block,"code",Size,0,2,"arm: return followed by a function"):-
    unresolved_block(Block,"code",Size),
    code_in_block_candidate_refined(EA,Block),
    arch.return(EA),
    next(EA,EANext),
    function_symbol(EANext,_).

/**
`Address_in_data` with no explicit reference often happens to be ldmdaeq:
E.g.,
<  .word .L_8171bc9
<  .word .L_81501ba
---
>
>  ldmdaeq r7, { r0, r3, r6, r7, r8, sb, fp, ip }
>  ldmdaeq r5, { r1, r3, r4, r5, r7, r8 }
*/
negative_block_points(Block,"code",Size,0,-7,"arm: ldmdaeq"):-
    code_in_block_candidate_refined(EA,Block),
    block_candidate_boundaries(Block,"code",Start,End),
    Size = End-Start,
    instruction_get_operation(EA,Operation),
    contains("LDM",Operation),
    (
        next(EA,EA2)
        ;
        next(EA2,EA)
    ),
    instruction_get_operation(EA2,Operation),
    instruction_get_dest_op(EA,_,DestOp1),
    op_regdirect_contains_reg(DestOp1,Reg),
    instruction_get_dest_op(EA2,_,DestOp2),
    op_regdirect_contains_reg(DestOp2,Reg).

/**
0x00000000 is unlikely a real instruction.
*/
negative_block_points(Block,"code",Size,0,-2,"arm: contains unplausible instr"):-
    code_in_block_candidate_refined(EA,Block),
    block_candidate_boundaries(Block,"code",Start,End),
    Size = End-Start,
    (EA band 1) = 0,
    data_word(EA,4,0).

/**
A code block that must fall through to a function symbol, and overlaps with a
literal pool is highly likely false.
*/
negative_block_points(Block,"code",Size,0,-9,"arm: possibly a litpool followed by a function symbol"):-
    code_in_block_candidate_refined(EA,Block),
    unresolved_block_overlap(Block,"code",Size,BlockLitPool,"data",_),
    litpool_boundaries(BlockLitPool,_),
    must_fallthrough(EA,BlockSucc),
    Block != BlockSucc,
    function_symbol(BlockSucc,_).

/**
This is similar to the one above, but weaker.
In some cases, the data bytes prior to a function symbol may not be explicitly
referenced as a literal pool.
*/
negative_block_points(Block,"code",Size,0,-1,"arm: must-fallthrough to a function symbol is not likely code"):-
    code_in_block_candidate_refined(EA,Block),
    block_candidate_boundaries(Block,"code",Start,End),
    Size = End-Start,
    must_fallthrough(EA,BlockSucc),
    Block != BlockSucc,
    function_symbol(BlockSucc,_).

data_block_candidate(Block,Pt_size):-
    aligned_address_in_data(Block,Addr),
    ascii_string(Addr,_),
    arch.pointer_size(Pt_size).

block_points(Block,"data",Size,0,2,"arm: pointer to string in data"):-
    aligned_address_in_data(Block,Addr),
    arch.pointer_size(Size),
    ascii_string(Addr,_),
    // The string does not overlap with a possible literal pool.
    align_addr(Addr_aligned,Addr),
    !litpool_boundaries(Addr_aligned,_).

/**
On top of the above, if there's another string nearby, give more points.
*/
block_points(Block,"data",Size,0,3,"arm: pointer to string adjacent to another strings in data"):-
    block_points(Block,"data",Size,0,2,"arm: pointer to string in data"),
    aligned_address_in_data(Block,Addr),
    (
        ascii_string(_,Addr)
        ;
        ascii_string(Addr,End),
        ascii_string(End,_)
    ).

// First data_block of the jump table gets lots of points,
// since the tbh instruction must have some corresponding entries.
block_points(TableStart,"data",Size,0,Points,"arm: jump table"):-
    arm_jump_table_data_block(_,TableStart,TableStart,Size),
    unresolved_block(TableStart,"data",Size),
    (
        !defined_symbol(TableStart,_,_,_,_,_,_,_,"$d"), Points = 15
        ;
        // If it's a defined symbol, the points 10 are already given.
        defined_symbol(TableStart,_,_,_,_,_,_,_,"$d"), Points = 5
    ).

// Subsequent data blocks compete with code blocks.
// Give a few points to encourage selection unless there's a compelling reason
// to select the code.
block_points(Block,"data",Size,0,2,"arm: jump table"):-
    arm_jump_table_data_block(_,TableStart,Block,Size),
    unresolved_block(Block,"data",Size),
    Block != TableStart.

// Give points to a jump table entry block if its end corresponds with the
// first target code block of the jump table.
block_points(Block,"data",BlockSize,0,10,"arm: jump table fits target"):-
    arm_jump_table_data_block(EA_jump,TableStart,Block,BlockSize),
    unresolved_block(Block,"data",BlockSize),
    arm_jump_table_candidate(EA_jump,_,TableStart,Block,Size,_,_,_,_),
    FirstTargetAddr = min TargetAddr : {
        arm_jump_table_candidate(EA_jump,_,TableStart,EA,_,TargetAddr,_,_,_),
        // Only consider targets that would exist if Block were the last block
        // of entries.
        EA < Block + BlockSize,
        // Only find Targets *after* the jump table (can be before in signed or
        // absolute jump tables)
        TargetAddr > TableStart
    },
    AlignedFirstTargetAddr = FirstTargetAddr - (FirstTargetAddr band 1),
    (
        // Perfect alignment.
        Block + BlockSize = AlignedFirstTargetAddr,
        UNUSED(Size)
        ;
        // Aligns, but there's an extra byte at the end of a tbb jumptable,
        // because there were an odd number of real targets.
        // Compilers may insert a zero byte to fill it.
        Size = 1,
        (Block + BlockSize) band 1 = 1,
        Block + BlockSize + 1 = AlignedFirstTargetAddr,
        data_byte(Block + BlockSize,0)
    ),
    // Don't apply this rule to first block of entries - it already gets 15 points.
    Block != TableStart.

block_points(TargetEA,"code",CodeSize,0,3,"arm: jump table target"):-
    arm_jump_table_data_block(EA_jmp,TableStart,Block,BlockSize),
    arm_jump_table_candidate(EA_jmp,_,TableStart,DataEA,Size,TargetEA,_,_,_),
    Block <= DataEA, DataEA+Size <= Block+BlockSize,
    unresolved_block(TargetEA,"code",CodeSize).

must_access_data(EA,Dest,Size):-
    litpool_ref(EA,EA,Dest,_,Size,_).

/**
ArchInfo auxdata inferred by the presence of specific instructions or patterns.
*/
.decl inferred_arch_info(Key:symbol,Value:symbol)
.output inferred_arch_info

// "System" is not a true hardware profile, but represents
// Application OR RealTime profiles.

// "blx label" is not possible on the "Microcontroller" profile.
inferred_arch_info("Profile","System"):-
    !arch_info("Profile",_),
    code_in_refined_block(EA,_),
    instruction_get_operation(EA,Operation),
    substr(Operation,0,3) = "BLX",
    arch.jump_operation_op_index(Operation,OpIndex),
    instruction_get_op(EA,OpIndex,Op),
    op_immediate(Op,_).

// ARM code is not possible on the "Microcontroller" profile.
inferred_arch_info("Profile","System"):-
    !arch_info("Profile",_),
    code_in_refined_block(EA,_),
    EA band 1 = 0.

inferred_arch_info("Profile","Microcontroller"):-
    !arch_info("Profile",_),
    code_in_refined_block(EA,_),
    instruction_get_operation(EA,Operation),
    (
        // The following instructions are only decoded with CS_MODE_MCLASS.
        // TODO: *some* MRS/MSR can be decoded without CS_MODE_MCLASS. We
        // should refine this rule to only match the ones that cannot.
        substr(Operation,0,3) = "MRS";
        substr(Operation,0,3) = "MSR"
    ).

// LDCL is not available on ARMv8+
// It could be v7 or anything older, but we guess v7 to provide maximum
// compatibility.
inferred_arch_info("Arch","v7"):-
    !arch_info("Arch",_),
    code_in_refined_block(EA,_),
    instruction_get_operation(EA,"LDCL").

// Create a target only if there's only one possible instruction mode at the
// address. Creating both as potential targets creates too many false
// positives.
basic_target(Inst):-
    arm_exidx_entry(Start,_),
    arch.instruction_at(Start,Inst),
    invalid(Inst bxor 1,_).

// Always split blocks at arm_exidx_entry.
block_limit(Inst):-
    arm_exidx_entry(Start,_),
    arch.instruction_at(Start,Inst).

// exidx metadata doesn't set the low bit to indicate Thumb, so we can only use
// it as a source of known block if the address isn't both an ARM and Thumb
// block.
known_block(Block,"code",BlockEnd - BlockBeg,".ARM.exidx"):-
    arm_exidx_entry(Start,0),
    arch.instruction_at(Start,Block),
    block_candidate_boundaries(Block,"code",BlockBeg,BlockEnd),
    !block_candidate_boundaries(Block bxor 1,"code",_,_).

// a block that overlaps both potential .ARM.exidx functions must not exist.
impossible_block(Other,"data",DataEnd - DataStart,"overlaps .ARM.exidx"):-
    arm_exidx_entry(Start,0),
    BlockArm = Start,
    BlockThumb = Start bor 1,
    block_candidate_boundaries(BlockArm,"code",_,EndArm),
    block_candidate_boundaries(BlockThumb,"code",_,EndThumb),
    block_candidate_boundaries(Other,"data",DataStart,DataEnd),
    DataStart < min(EndArm, EndThumb),
    Start < DataEnd.
